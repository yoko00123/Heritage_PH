{"_id":"esqx3mxMhO09lpc6","shortid":"Hkh497UKQ","recipe":"phantom-pdf","engine":"handlebars","modificationDate":"2018-10-11T08:39:28.096Z","data":{"shortid":"rkEtKN8Y7"},"resources":{"items":[{"shortid":"rkEtKN8Y7","entitySet":"data"}]},"phantom":{"orientation":"landscape","margin":"{\"top\":\"25px\",\"left\":\"25px\",\"right\":\"10px\",\"bottom\":\"25px\"}","footerHeight":"3cm","headerHeight":"3cm","fitToPage":true,"header":"<center>\n<table border = \"0\">\n<thead style=\"font-family: Verdana;\">\n        <tr>\n         <th style=\"border-style:none; text-align:center; color:black; font-size:14pt;\">{{Single DataSource \"Company\"}} </th>\n        </tr>\n      \n        <tr>\n        <th style=\"border-style:none; text-align:center; color:black; font-size:12pt;\">Audit Trail Report</th></tr>\n      \n    <tr>\n    <th style=\"border-style:none; text-align:center; color:black; font-size:10pt;\">{{SingleDate DataSource \"StartDate\" \"mmm dd, yyyy\"}} - {{SingleDate DataSource \"EndDate\" \"mmm dd, yyyy\"}}</th>\n    </tr>\n    \n</thead>\n</table>\n</center>","footer":"<div style='display: none' id='last'></div>\n<script>\n    if ({#pageNum} == {#numPages}) {\n        document.getElementById('last').style.display='block'\n    } else {\n        document.getElementById('last').style.display='none'\n    }\n</script>\n<br><br>\n<div style=\"float:left;  font-size:8pt; font-family:Verdana;\"> Print Date: {{formatDate Date 'mmm dd, yyyy'}}<br>\n Print Time: {{formatDate Time 'h:MM TT'}}  </div>\n  <div style=\"float:right; font-size:8pt; font-family:Verdana;\">{#pageNum}/{#numPages}</div>"},"name":"Audit Trail Report","content":"<style>\n    table \n    {\n    width: 100%; \n    }\n    /*thead > tr > th,  [border-bottom] {*/\n    /*    border-bottom: 1px solid black;*/\n    /*    padding-bottom:5px;*/\n    /*}*/\n    /*tfoot > tr > th, [border-top]{*/\n    /*    border-top: 1px  solid black;*/\n    /*    padding-top: 5px;*/\n    /*}*/\n    p\n    {\n    font-size: 25;\n    }\n    \n    [center] {\n        text-align: center;\n    }\n    \n    [bold] \n    {\n    font-weight: bold;\n    }\n    \n    [padding-20] {\n        padding-left : 20px;\n    }\n  [total]{\n      font-weight:bold;\n      font-size:25px;\n  }\n  [bot-border]{\n      border-bottom:1px solid black;\n   \n  }\n  [padding-bot]{\n       padding-bottom:10px;\n  }\n  [top-margin]{\n      margin-top:35px;\n  }\n  /*thead { display: table-row-group } */\n</style>\n\n<!-- Created by Yoku -->\n<table>\n     {{#group DataSource by=\"$.ID_Session\"}}\n  <thead style=\"font:12pt Verdana;\">  \n  <tr style=\"font:10pt Verdana;\" border=\"0px\">\n            <th padding-bot style=\"text-align:left;\">Store Code</th>\n            <th padding-bot style=\"text-align:left;\">Cost Center</th>\n            <th padding-bot style=\"text-align:left;\">Store Name</th>\n            <th padding-bot style=\"text-align:left;\">Date</th>\n            <th padding-bot style=\"text-align:left;\">Employee No. (Record Edited)</th>\n            <th padding-bot style=\"text-align:left;\">Employee Name (Record Edited)</th>\n            <th padding-bot style=\"text-align:left;\">Record Edited</th>\n            <th padding-bot style=\"text-align:left;\">Action</th>\n            <th padding-bot style=\"text-align:left;\">Other Details</th>\n            <th padding-bot style=\"text-align:left;\">Edited by</th>\n            <th padding-bot style=\"text-align:left;\">Date Edited</th>\n            <th padding-bot style=\"text-align:left;\">Time Edited</th>\n        </tr>\n    <tr>\n     <td colspan=\"200\" style=\" border-bottom:1px solid black;\"></td>\n    </tr>\n          <tr><td></td></tr><tr><td></td></tr>\n          <tr><td></td></tr><tr><td></td></tr>\n          <tr><td></td></tr><tr><td></td></tr>\n          <tr><td></td></tr><tr><td></td></tr>\n          <tr><td></td></tr><tr><td></td></tr>\n          <tr><td></td></tr><tr><td></td></tr>\n    </thead>\n      {{/group}}\n<tbody>\n  \n          {{#each DataSource}}\n            <tr>\n            <td style=\"text-align:left; font-size:10pt;\">{{StoreName}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{CostCenterName}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{StoreName}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{formatDate Date \"mmm dd, yyyy\"}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{EmployeeCode}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{Name}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{ModuleName}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{AuditTrailType}}</td>\n\n            <td style=\"text-align:left; font-size:10pt;\">{{ParentModule}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{Username}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{formatDate DateTime \"mmm dd, yyyy\"}}</td>\n            <td style=\"text-align:left; font-size:10pt;\">{{formatDate DateTime \"h:MM tt\"}}</td>\n            </tr>\n           {{/each}}\n      \n</tbody>\n<tfooter>\n\n    \n</tfooter>\n</table>","helpers":"//Set number of computed columns\r\nvar _count = 2; // 2 = how many columns will have to add\r\nvar _total = new Array(2);\r\nvar _grandtotal = new Array(2);\r\nvar _grand = 0;\r\n//Edited by Yoku 06082018\r\n\r\n\r\n\r\n//Set initial value of totals\r\nfor (var i = 0; i < _count; i++) {\r\n    _total[i] = 0.00;\r\n    _grandtotal[i] = 0.00;\r\n}\r\n\r\n//Update total values and grand total values\r\nfunction InitGroup(val) {\r\n    for (var i = 0; i < _grandtotal.length; i++) {\r\n        _grandtotal[i] += _total[i];\r\n        _total[i] = 0.00;\r\n    }\r\n    return val;\r\n}\r\n\r\n//Return total value based on index\r\nfunction GetTotal(index) {\r\n    return AddComma(_total[index].toFixed(2));\r\n\r\n}\r\n\r\nfunction get(obj, prop) {\r\n    var parts = prop.split('.'),\r\n        last = parts.pop();\r\n\r\n    while ((prop = parts.shift())) {\r\n        obj = obj[prop];\r\n\r\n        if (obj === null) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    return obj[last];\r\n}\r\n\r\n\r\n//Return grand total value based on index\r\nfunction GetGrandTotal(index) {\r\n    return AddComma(_grandtotal[index].toFixed(2));\r\n}\r\n\r\n//Updates amount\r\n//Change zero amount to '-'\r\n\r\nfunction CheckZero(index, amt) {\r\n    _total[index] += parseFloat(amt);\r\n    return parseFloat(amt) > 0 ? AddComma(amt.toFixed(2)) : amt.toFixed(2);\r\n    if (amt === 0)\r\n        return parseFloat(amt) > 0 ? amt.toFixed(2) : '0';\r\n}\r\n\r\nfunction getValueByColumn(ls, columnfilter, columnfiltervalue, columnresult) {\r\n    var gg = Enumerable\r\n        .From(ls)\r\n        .Where(function(x) {\r\n            return x[columnfilter] === columnfiltervalue\r\n        })\r\n        .Select('$.' + columnresult).FirstOrDefault(0);\r\n    return gg === 0 ? '-' : formatNumber(gg);\r\n}\r\n\r\nfunction getRowTotal(ls, columnfilter) {\r\n    var gg = Enumerable.From(ls).Sum('$.' + columnfilter);\r\n    return gg === 0 ? '-' : formatNumber(gg);\r\n}\r\n\r\nfunction getGroupTotalByColumn(ls, columnfilter, columnfiltervalue, columnresult) {\r\n    var gg = Enumerable\r\n        .From(ls)\r\n        .Where(function(x) {\r\n            return x[columnfilter] === columnfiltervalue\r\n        })\r\n        .Select('$.' + columnresult).Sum();\r\n    return gg === 0 ? '-' : formatNumber(gg);\r\n}\r\n\r\nfunction GetGrandTotal(index, amt) {\r\n    _grandtotal[index] += parseFloat(amt);\r\n    //return parseFloat(amt) > 0 ? AddComma(amt.toFixed(2)) : amt.toFixed(2);\r\n    return parseFloat(amt) > 0 ? amt.toFixed(2) : '-';\r\n}\r\n\r\nfunction AddComma(x) {\r\n    return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n}\r\n\r\n//-->>\r\n\r\nfunction Single(ds, col) {\r\n    if (ds.length === 0) return '';\r\n    return ds[0][col];\r\n}\r\n\r\nfunction formatNumber(x, decimal) {\r\n    var parts = parseFloat(x).toFixed(decimal || 2).toString().split(\".\");\r\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n    return parts.join(\".\");\r\n}\r\n\r\nfunction SingleDate(ds, col, frmt) {\r\n    var gg = Single(ds, col);\r\n    return DateTime.Format(gg, frmt)\r\n}\r\n\r\nfunction formatDate(dt, frmt) {\r\n    return DateTime.Format(dt, frmt);\r\n}\r\n\r\nfunction Sum(itms) {\r\n    return itms.length;\r\n}\r\n\r\nvar DateTime = (function() {\r\n    return {\r\n        Format: function() {\r\n            var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|\"[^\"]*\"|'[^']*'/g,\r\n                timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\r\n                timezoneClip = /[^-+\\dA-Z]/g,\r\n                pad = function(val, len) {\r\n                    val = String(val);\r\n                    len = len || 2;\r\n                    while (val.length < len) val = \"0\" + val;\r\n                    return val;\r\n                };\r\n\r\n            // Regexes and supporting functions are cached through closure\r\n            return function(date, mask, utc) {\r\n                //var dF = DateTime.Format;\r\n                if (DateTime.IsNewtonFormat(date))\r\n                    date = date.replace('T', ' ');\r\n\r\n                // You can't provide utc if you skip other args (use the \"UTC:\" mask prefix)\r\n                if (arguments.length == 1 && Object.prototype.toString.call(date) == \"[object String]\" && !/\\d/.test(date)) {\r\n                    mask = date;\r\n                    date = undefined;\r\n                }\r\n\r\n                // Passing date through Date applies Date.parse, if necessary\r\n                date = date ? new Date(date) : new Date;\r\n                if (isNaN(date)) throw SyntaxError(\"invalid date\");\r\n\r\n                //mask = String(dF.masks[mask] || mask || dF.masks[\"default\"]);\r\n                mask = String(DateTime.masks[mask] || mask || DateTime.masks['default']);\r\n\r\n                // Allow setting the utc argument via the mask\r\n                if (mask.slice(0, 4) == \"UTC:\") {\r\n                    mask = mask.slice(4);\r\n                    utc = true;\r\n                }\r\n\r\n                var _ = utc ? \"getUTC\" : \"get\",\r\n                    d = date[_ + \"Date\"](),\r\n                    D = date[_ + \"Day\"](),\r\n                    m = date[_ + \"Month\"](),\r\n                    y = date[_ + \"FullYear\"](),\r\n                    H = date[_ + \"Hours\"](),\r\n                    M = date[_ + \"Minutes\"](),\r\n                    s = date[_ + \"Seconds\"](),\r\n                    L = date[_ + \"Milliseconds\"](),\r\n                    o = utc ? 0 : date.getTimezoneOffset(),\r\n                    flags = {\r\n                        d: d,\r\n                        dd: pad(d),\r\n                        ddd: DateTime.i18n.dayNames[D], // dF.i18n.dayNames[D],\r\n                        dddd: DateTime.i18n.dayNames[D + 7],\r\n                        m: m + 1,\r\n                        mm: pad(m + 1),\r\n                        mmm: DateTime.i18n.monthNames[m],\r\n                        mmmm: DateTime.i18n.monthNames[m + 12],\r\n                        yy: String(y).slice(2),\r\n                        yyyy: y,\r\n                        h: H % 12 || 12,\r\n                        hh: pad(H % 12 || 12),\r\n                        H: H,\r\n                        HH: pad(H),\r\n                        M: M,\r\n                        MM: pad(M),\r\n                        s: s,\r\n                        ss: pad(s),\r\n                        l: pad(L, 3),\r\n                        L: pad(L > 99 ? Math.round(L / 10) : L),\r\n                        t: H < 12 ? \"a\" : \"p\",\r\n                        tt: H < 12 ? \"am\" : \"pm\",\r\n                        T: H < 12 ? \"A\" : \"P\",\r\n                        TT: H < 12 ? \"AM\" : \"PM\",\r\n                        Z: utc ? \"UTC\" : (String(date).match(timezone) || [\"\"]).pop().replace(timezoneClip, \"\"),\r\n                        o: (o > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\r\n                        S: [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\r\n                    };\r\n\r\n                return mask.replace(token, function($0) {\r\n                    return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\r\n                });\r\n            };\r\n        }(),\r\n        masks: {\r\n            \"default\": \"ddd mmm dd yyyy HH:MM:ss\",\r\n            shortDate: \"m/d/yy\",\r\n            mediumDate: \"mmm dd, yyyy\",\r\n            longDate: \"mmmm d, yyyy\",\r\n            fullDate: \"dddd, mmmm d, yyyy\",\r\n            shortTime: \"h:MM TT\",\r\n            mediumTime: \"h:MM:ss TT\",\r\n            longTime: \"h:MM:ss TT Z\",\r\n            isoDate: \"yyyy-mm-dd\",\r\n            isoTime: \"HH:MM:ss\",\r\n            isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\r\n            isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\",\r\n            inSysDateTime: \"hh:MM TT mmm dd, yyyy\",\r\n            sometime: 'hhMMss',\r\n            shortDate2: \"mm/dd/yyyy\",\r\n            jDPInsysDate: \"M dd, yyyy\"\r\n        },\r\n        i18n: {\r\n            dayNames: [\r\n                \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\",\r\n                \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\r\n            ],\r\n            monthNames: [\r\n                \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n                \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n            ]\r\n        },\r\n        JSONDate: function(jsonDate, format) {\r\n            //console.log(jsonDate.match(/\\d+/)[0]);\r\n\r\n            var d = new Date(parseInt(jsonDate.substr(6)));\r\n\r\n            return DateTime.Format(d, format);\r\n        },\r\n        ShortDate2: function(dateValue) {\r\n            date = new Date();\r\n\r\n            if (typeof dateValue != 'undefined')\r\n                date = dateValue;\r\n\r\n            return DateTime.Format(date, DateTime.masks.shortDate2)\r\n        },\r\n        Between: function(sdate, edate, callback, onFinish) {\r\n            try {\r\n                var i = 0;\r\n                var d = sdate;\r\n                while (true) {\r\n                    if (d >= edate) {\r\n                        onFinish();\r\n                        break;\r\n                    } else\r\n                        callback(i, d);\r\n\r\n                    d.setTime(d.getTime() + 86400000);\r\n                    i++;\r\n                }\r\n            } catch (ex) {\r\n                console.error('DateTime.Between', ex);\r\n            }\r\n        },\r\n        ToDate: function(jsonDate) {\r\n            return new Date(parseInt(jsonDate.substr(6)));\r\n        },\r\n        IsNewtonFormat: function(dte) {\r\n            return /^(\\d{4})-(\\d{1,2})-(\\d{1,2})T(\\d{1,2}):(\\d{1,2}):(\\d{1,2})?.(\\d{1,3})?$/.test(dte);\r\n            //return /^(\\d{4})-(\\d{1,2})-(\\d{1,2})T(\\d{1,2}):(\\d{1,2}):(\\d{1,2})+(.\\d{3})?$/.test(dte);\r\n        }\r\n    }\r\n}())\r\n\r\nfunction get(obj, prop) {\r\n    var parts = prop.split('.'),\r\n        last = parts.pop();\r\n\r\n    while ((prop = parts.shift())) {\r\n        obj = obj[prop];\r\n\r\n        if (obj === null) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    return obj[last];\r\n}\r\n\r\nfunction noop() {\r\n    return '';\r\n}\r\n\r\nfunction groupBy(handlebars) {\r\n    var helpers = {\r\n        /**\r\n         * @method group\r\n         * @param {Array} list\r\n         * @param {Object} options\r\n         * @param {Object} options.hash\r\n         * @param {String} options.hash.by\r\n         * @return {String} Rendered partial.\r\n         */\r\n        group: function(list, options) {\r\n            options = options || {};\r\n\r\n            var fn = options.fn || noop,\r\n                inverse = options.inverse || noop,\r\n                hash = options.hash,\r\n                prop = hash && hash.by,\r\n                keys = [],\r\n                groups = {};\r\n\r\n            if (!prop || !list || !list.length) {\r\n                return inverse(this);\r\n            }\r\n\r\n            function groupKey(item) {\r\n                var key = get(item, prop);\r\n\r\n                if (keys.indexOf(key) === -1) {\r\n                    keys.push(key);\r\n                }\r\n\r\n                if (!groups[key]) {\r\n                    groups[key] = {\r\n                        value: key,\r\n                        items: []\r\n                    };\r\n                }\r\n\r\n                groups[key].items.push(item);\r\n            }\r\n\r\n            function renderGroup(buffer, key) {\r\n                return buffer + fn(groups[key]);\r\n            }\r\n\r\n            list.forEach(groupKey);\r\n\r\n            return keys.reduce(renderGroup, '');\r\n        }\r\n    };\r\n\r\n    handlebars.registerHelper(helpers);\r\n\r\n    return handlebars;\r\n}\r\n\r\nhandlebars.registerHelper(groupBy(handlebars));\r\n\r\n\r\n//Edited by Yoku 06082018\r\n\r\n\r\n\r\nvar ctr = 0;\r\n\r\n//Set initial value of totals\r\nfor (var i = 0; i < _count; i++) {\r\n    _total[i] = 0.00;\r\n    _grandtotal[i] = 0.00;\r\n}\r\n\r\n//Update total values and grand total values\r\nfunction InitGroup(val) {\r\n    for (var i = 0; i < _grandtotal.length; i++) {\r\n        _grandtotal[i] += _total[i];\r\n        _total[i] = 0.00;\r\n    }\r\n    return val;\r\n}\r\n\r\n//Return total value based on index\r\nfunction GetTotal(index) {\r\n    return AddComma(_total[index].toFixed(2));\r\n}\r\n\r\nfunction Count(list) {\r\n    return list.length;\r\n}\r\n\r\n//Return grand total value based on index\r\nfunction GetGrandTotal(index) {\r\n    return AddComma(_grandtotal[index].toFixed(2));\r\n}\r\n\r\n//Updates amount\r\n//Change zero amount to '-'\r\nfunction CheckZero(index, amt) {\r\n    _total[index] += parseFloat(amt);\r\n    return parseFloat(amt) > 0 ? AddComma(amt) : amt;\r\n    //return parseFloat(amt) > 0 ? amt.toFixed(2) : '-';\r\n}\r\n\r\nfunction AddComma(x) {\r\n    return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\r\n}\r\n\r\nfunction FormatDate(dt, frmt) {\r\n    return DateTime.Format(dt, frmt);\r\n}\r\n\r\nfunction GetGrand() {\r\n    return _grand;\r\n}\r\n\r\nfunction Sum(itms) {\r\n    _grand += itms.length;\r\n    return itms.length;\r\n}\r\n\r\nvar DateTime = (function() {\r\n    return {\r\n        Format: function() {\r\n            var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|\"[^\"]*\"|'[^']*'/g,\r\n                timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\r\n                timezoneClip = /[^-+\\dA-Z]/g,\r\n                pad = function(val, len) {\r\n                    val = String(val);\r\n                    len = len || 2;\r\n                    while (val.length < len) val = \"0\" + val;\r\n                    return val;\r\n                };\r\n\r\n            // Regexes and supporting functions are cached through closure\r\n            return function(date, mask, utc) {\r\n                //var dF = DateTime.Format;\r\n                if (DateTime.IsNewtonFormat(date))\r\n                    date = date.replace('T', ' ');\r\n\r\n                // You can't provide utc if you skip other args (use the \"UTC:\" mask prefix)\r\n                if (arguments.length == 1 && Object.prototype.toString.call(date) == \"[object String]\" && !/\\d/.test(date)) {\r\n                    mask = date;\r\n                    date = undefined;\r\n                }\r\n\r\n                // Passing date through Date applies Date.parse, if necessary\r\n                date = date ? new Date(date) : new Date;\r\n                if (isNaN(date)) throw SyntaxError(\"invalid date\");\r\n\r\n                //mask = String(dF.masks[mask] || mask || dF.masks[\"default\"]);\r\n                mask = String(DateTime.masks[mask] || mask || DateTime.masks['default']);\r\n\r\n                // Allow setting the utc argument via the mask\r\n                if (mask.slice(0, 4) == \"UTC:\") {\r\n                    mask = mask.slice(4);\r\n                    utc = true;\r\n                }\r\n\r\n                var _ = utc ? \"getUTC\" : \"get\",\r\n                    d = date[_ + \"Date\"](),\r\n                    D = date[_ + \"Day\"](),\r\n                    m = date[_ + \"Month\"](),\r\n                    y = date[_ + \"FullYear\"](),\r\n                    H = date[_ + \"Hours\"](),\r\n                    M = date[_ + \"Minutes\"](),\r\n                    s = date[_ + \"Seconds\"](),\r\n                    L = date[_ + \"Milliseconds\"](),\r\n                    o = utc ? 0 : date.getTimezoneOffset(),\r\n                    flags = {\r\n                        d: d,\r\n                        dd: pad(d),\r\n                        ddd: DateTime.i18n.dayNames[D], // dF.i18n.dayNames[D],\r\n                        dddd: DateTime.i18n.dayNames[D + 7],\r\n                        m: m + 1,\r\n                        mm: pad(m + 1),\r\n                        mmm: DateTime.i18n.monthNames[m],\r\n                        mmmm: DateTime.i18n.monthNames[m + 12],\r\n                        yy: String(y).slice(2),\r\n                        yyyy: y,\r\n                        h: H % 12 || 12,\r\n                        hh: pad(H % 12 || 12),\r\n                        H: H,\r\n                        HH: pad(H),\r\n                        M: M,\r\n                        MM: pad(M),\r\n                        s: s,\r\n                        ss: pad(s),\r\n                        l: pad(L, 3),\r\n                        L: pad(L > 99 ? Math.round(L / 10) : L),\r\n                        t: H < 12 ? \"a\" : \"p\",\r\n                        tt: H < 12 ? \"am\" : \"pm\",\r\n                        T: H < 12 ? \"A\" : \"P\",\r\n                        TT: H < 12 ? \"AM\" : \"PM\",\r\n                        Z: utc ? \"UTC\" : (String(date).match(timezone) || [\"\"]).pop().replace(timezoneClip, \"\"),\r\n                        o: (o > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\r\n                        S: [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\r\n                    };\r\n\r\n                return mask.replace(token, function($0) {\r\n                    return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\r\n                });\r\n            };\r\n        }(),\r\n        masks: {\r\n            \"default\": \"ddd mmm dd yyyy HH:MM:ss\",\r\n            shortDate: \"m/d/yy\",\r\n            mediumDate: \"mmm dd, yyyy\",\r\n            longDate: \"mmmm d, yyyy\",\r\n            fullDate: \"dddd, mmmm d, yyyy\",\r\n            shortTime: \"h:MM TT\",\r\n            mediumTime: \"h:MM:ss TT\",\r\n            longTime: \"h:MM:ss TT Z\",\r\n            isoDate: \"yyyy-mm-dd\",\r\n            isoTime: \"HH:MM:ss\",\r\n            isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\r\n            isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\",\r\n            inSysDateTime: \"hh:MM TT mmm dd, yyyy\",\r\n            sometime: 'hhMMss',\r\n            shortDate2: \"mm/dd/yyyy\",\r\n            jDPInsysDate: \"M dd, yyyy\"\r\n        },\r\n        i18n: {\r\n            dayNames: [\r\n                \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\",\r\n                \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"\r\n            ],\r\n            monthNames: [\r\n                \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n                \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n            ]\r\n        },\r\n        JSONDate: function(jsonDate, format) {\r\n            //console.log(jsonDate.match(/\\d+/)[0]);\r\n\r\n            var d = new Date(parseInt(jsonDate.substr(6)));\r\n\r\n            return DateTime.Format(d, format);\r\n        },\r\n        ShortDate2: function(dateValue) {\r\n            date = new Date();\r\n\r\n            if (typeof dateValue != 'undefined')\r\n                date = dateValue;\r\n\r\n            return DateTime.Format(date, DateTime.masks.shortDate2)\r\n        },\r\n        Between: function(sdate, edate, callback, onFinish) {\r\n            try {\r\n                var i = 0;\r\n                var d = sdate;\r\n                while (true) {\r\n                    if (d >= edate) {\r\n                        onFinish();\r\n                        break;\r\n                    } else\r\n                        callback(i, d);\r\n\r\n                    d.setTime(d.getTime() + 86400000);\r\n                    i++;\r\n                }\r\n            } catch (ex) {\r\n                console.error('DateTime.Between', ex);\r\n            }\r\n        },\r\n        ToDate: function(jsonDate) {\r\n            return new Date(parseInt(jsonDate.substr(6)));\r\n        },\r\n        IsNewtonFormat: function(dte) {\r\n            return /^(\\d{4})-(\\d{1,2})-(\\d{1,2})T(\\d{1,2}):(\\d{1,2}):(\\d{1,2})?.(\\d{1,3})?$/.test(dte);\r\n            //return /^(\\d{4})-(\\d{1,2})-(\\d{1,2})T(\\d{1,2}):(\\d{1,2}):(\\d{1,2})+(.\\d{3})?$/.test(dte);\r\n        }\r\n    }\r\n}())\r\n\r\nfunction get(obj, prop) {\r\n    var parts = prop.split('.'),\r\n        last = parts.pop();\r\n\r\n    while ((prop = parts.shift())) {\r\n        obj = obj[prop];\r\n\r\n        if (obj == null) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    return obj[last];\r\n}\r\n\r\nfunction noop() {\r\n    return '';\r\n}\r\n\r\nfunction groupBy(handlebars) {\r\n    var helpers = {\r\n        /**\r\n         * @method group\r\n         * @param {Array} list\r\n         * @param {Object} options\r\n         * @param {Object} options.hash\r\n         * @param {String} options.hash.by\r\n         * @return {String} Rendered partial.\r\n         */\r\n        group: function(list, options) {\r\n            options = options || {};\r\n\r\n            var fn = options.fn || noop,\r\n                inverse = options.inverse || noop,\r\n                hash = options.hash,\r\n                prop = hash && hash.by,\r\n                keys = [],\r\n                groups = {};\r\n\r\n            if (!prop || !list || !list.length) {\r\n                return inverse(this);\r\n            }\r\n\r\n            function groupKey(item) {\r\n                var key = get(item, prop);\r\n\r\n                if (keys.indexOf(key) === -1) {\r\n                    keys.push(key);\r\n                }\r\n\r\n                if (!groups[key]) {\r\n                    groups[key] = {\r\n                        value: key,\r\n                        items: []\r\n                    };\r\n                }\r\n\r\n                groups[key].items.push(item);\r\n            }\r\n\r\n            function renderGroup(buffer, key) {\r\n                return buffer + fn(groups[key]);\r\n            }\r\n\r\n            list.forEach(groupKey);\r\n\r\n            return keys.reduce(renderGroup, '');\r\n        }\r\n    };\r\n\r\n    handlebars.registerHelper(helpers);\r\n\r\n    return handlebars;\r\n}\r\n\r\nhandlebars.registerHelper(groupBy(handlebars));\r\n\r\nfunction Single(ds, col) {\r\n    if (ds.length === 0) return '';\r\n    return ds[0][col];\r\n}\r\n\r\nfunction SingleDate(ds, col, frmt) {\r\n    var gg = Single(ds, col);\r\n    return DateTime.Format(gg, frmt)\r\n}"}